### Grounded Graph Variables: Foundations for Artificial General Intelligence

Variables. Perhaps the very first concept any programmer would learn. It is however THE bottleneck in the progress towards artificial general Intelligence. The root cause of how we treat variables in programming can be traced back to the Unix operating system, when the concept of process was popularized. As such, variables become isolated within a process, cutting it off from the rest of the system, and the rest of the world.

How can this be overcome? We propose grounded graph variables (GGV), an implementation of variables that are related to other variables stored in random access memory (RAM), disk storage or networks. This is an extension of graph database to cover variables in memory. 

Mind_as_Graph: find link, put here. This is our novel fundamental assumption. Give example, everything we think is related to each other. Android facedetect, judge distance, presence or absence, man in the mirror experiment (link), all is relative.

https://github.com/udexon/SAIGON/blob/master/Homoiconic_Graph_Machine.md

The readers may ask: there are literally billions of line of code written in thousands of programming languages since the beginning of the computing era; how long would it need to change those code and the current practices?

Graph theory itself offers a solution. We shall employ the Forth paradigm: piecewise function construction. Variables are defined in and manipulated in Conventional Programming Languages. After that, stack machine programming (SAIGON) adds graph grounding to the variables. 

Variables is a non topic in the Forth programming language as its usuage is discouraged. This is justified as stack programming is largely a temporal mechanism, ie. manipulating information using stack in sequence (one clock cycle after another). 

However, when there are multiple inputs and outputs that are not temporally related, they need to be stored as variables. Forth programmers have little need to work on such problems, perhaps not due to the limitations of Forth, but the nature of business -- there are just too many problems in this world that Forth programmers would focus on low level hardware related problems.

MIMO paradigm first became significant when GUI was popularized by capable and affordable Intel 386 personal computers. Microsoft Windows took the lead in numbers, Apple in innovative GUI from Steve Jobs NeXTSTEP, while GNU Linux played catch up game while leading in server technologies. 

Not much has changed although the mainstream development in 2019 is mobile applications.  

The biggest question is this: How do we interface mainstream programming paradigms to stack programming paradigm? Enter SAIGON and ISYA. 


Human senses are also limited. Hence we see and hear mostly, as inputs. Temporary variables in brain are bigger in number, as they are accumulated over time, based on inputs from sensory organs, and are used from time to time, when needed. People with short memory have less intellectual ability. 


Forth-ish piecewise function construction: Forthers call it colon definition. Non Forthers would have too many theoretical mental blocks due to paradigmatic differences. Thou shalt not .... for ....

Programming paradigms are like religions, where fanatical adherents would write emotionally against each other. While the common mortals do not have access to evidence artifacts beyond the Internet, most programmers would recall Dijkstra's admonition against "goto". We do not know for sure how paradigmatic factionalism has affected the desire of programmers in learning a certain programming language, but the number of subscribers to /r/Forth on Reddit might be a telling indicator, given its status as one of the oldest surviving programming languages. 

We bring this up in anticipation of reader's defense or offence arising from paradigmatic factionalism. We wish to show that how stack programming is so fundamental in programming that it is "paradigmless" -- perhaps the most sacred, or blasphemous, non vocabulary for any paradigmatic fanatics. 

So firstly, we must show that SAIGON is paradigmless, capable of running in any programming language. 

Graph grounding variables can be implemented without RPN, but that would not be homoiconic. Then the code is not graph grounded, although the data are. 

Explain stack machine shell. Unix shell pipe is one small step away to be stack. Can implement stack in bash. 

Any conventional program can add SMASH, open ended. Address security risk via other techniques. 

Smash leads to Indistinguishable executable form: overhead of indirect threading? Compiled, direct threaded code? Only C is compiled? Direct stack opcode? 


What happens when N processes become SMASH with grounded Graph variables on M devices worldwide? It will be Artificial General Intelligence. Programmers worldwide collaborate through Cloudias. 




Stack programming existed before any paradigm, so can call it pardigmless programming. More catchy. Make money with Android Metaprogramming Training?

Import section is too long. If independent block, save in SAIGON, all blocks are movable, not dependent on position in file? 

Is stack paradigm more efficient than others? Can prove by expressing proof in rpn? All other syntax can be expressed as RPN, for sure.

RPN is good for composing single function with limited variables? For multiple input multiple output need parallel representation, although single output to multiple input may use stack? Hence graph part of SAIGON. 

Stack is the simplest paradigm, hence discovered earliest, and other paradigms can be broken down to stack. It survived till now because of its usefulness and versatility. Other less useful paradigms may have been forgotten. 

Stack machine is a temporal mechanism. Graph is both spatial and temporal, is superset of stack machine. Need graph for multiple output systems, especially parallel. If serial, then is temporal. 

All programming languages have spatial and temporal components. local variables make spatial components unnecessarily complicated when they should be made temporal (stack). Most programs gave few output, are node reducing functions NF-. GUI real estate is limited too, hence number of outputs Should be limited. Hence spatial variables of any program should be limited. 


Occam's Razor to explain why no graph grounding on variables? Because Unix managed by processes, Forth by words, diverged in 1968. Forth not popular. Unix was. Third paradigm was MVC web SQL. Now all converge as SAIGON. 

Too many problems to solve for Forth programmers, none venture into Graph variables. Graph variables is better name than graph objects. GV is implementation. GObj is concept. 

Psychlab: a psychology laboratory for deep reinforcement learning agents
JZ Leibo, CM d'Autume, D Zoran, D Amos… - arXiv preprint arXiv …, 2018 - arxiv.org
Psychlab is a simulated psychology laboratory inside the first-person 3D game world of DeepMind Lab (Beattie et al. 2016). Psychlab enables implementations of classical laboratory psychological experiments so that they work with both human and artificial …
Cited by 6 Related articles   

Title [ Concept: Concept Relationship ]

Metaprogramming for Dummies: How to write an Android program without learning programming
